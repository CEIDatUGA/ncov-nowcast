---
title: "Nowcasting the current size of the COVID-19 outbreak in China"
author: "Tim Wildauer, Rachel Mercaldo, Eric Marty, John Drake"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}

library(tidyverse)
library(tibbletime)
library(padr)
library(tvReg)
library(forecast)
source('R/package.R')
source('R/deconcolve.R')
source('R/simple_tdar.R')
source('R/package_tv.R')

# functions

# function to trim NA's from a vector
trim_na <- function(x) {x[!is.na(x)]}

# function to pad a vector with NA's
pad_na <- function(x,n,front=FALSE) {
  if(front==TRUE){
    x <- c(rep.int(NA,n),x)
  }else{
    length(x) <- length(x)+n
  }
  return(x)
}

# function to replace tail of vector or dataframe with NA's
tail_na <- function(data, tail, columns=NULL) {
  d <- data
  if (is.vector(d)) {
    n <- length(d)
    # replace(data, (n-tail):n, NA)
    d[(n-tail[1]+1):n] <- NA
  }else{
    if (is.data.frame(d)) {
      n <- nrow(d)
      if(!is.null(columns)){c <- columns}else{c <- 1:length(data)}
      d[(n-tail[1]+1):n,c] <- NA
    }
  }
  return(d)
}

# function to calculate confidence intervals across rows of a dataframe
rowwise_confidence_intervals <- function(df,interval) {
  out <- list()
  for (i in 1:nrow(df)) {
    v <- unlist(df[i,])
    v_sd <- sd(v)
    v_n <- length(v)
    v_mean <- mean(v)
    error <- qt((interval + 1)/2, df = v_n - 1) * v_sd / sqrt(v_n)
    out$lower[i] <- v_mean - error
    out$upper[i] <- v_mean + error
  }
  return(out)
}

```


# Problem

We wish to estimate the total current size of the COVID-19 outbreak, i.e. the total number of people who have been infected with SARS-CoV2.

We need to estimate this number from the current count of confirmed cases of COVID-19. The count of confirmed cases does not include those who are sympotmatic but whose cases have not been confirmed, nor does it include those who have been exposed and cary the virus but are not yet symptomatic. 

In order to estimate the current outbreak size, we must add to the current case count an estimate of the current number of symptomatic individuals, and an estimate of the current number of exposed but not yet symptomatic individuals.

We first estimate the number of symptomatic indivuals at a previous time from the current case count, then extrapolate the number of sympotmatic individuals forward to the present. We then estimate the number exposed at a still earlier time from the estimated number symptomatic, and extrapolate that number forward to the present as well.

This procedure gives us an estimate, with error, of the current actual oubtreak size.

## Current Case Data in China

```{r data, echo=TRUE, message = FALSE, warning = FALSE}

# read data directly to google sheet.

sheet <- "https://docs.google.com/spreadsheets/d/1gTj4zFMfXRk92CCQAOwa04ZBhqJ4oSmQFm_nb8-YXbw/edit#gid=1767307356"

china_province_data_cases_latest <- googlesheets4::sheets_read(sheet) 

# Create a Time Tibble; and sum provinces

cases <- china_province_data_cases_latest %>%  
  # select(-`Hubei (clinical)`) %>% 
  # rename(Date = `Date (CST)`) %>% 
  rename(Inner_Mongolia = `Inner\nMongolia`) %>% 
  mutate(Date = as.Date(Date)) %>% 
  padr::pad(start_val = as.Date("2019-12-01")) %>%
  replace(., is.na(.), 0) %>%
  tibbletime::as_tbl_time(index=Date) %>% 
  mutate(China = rowSums(.[,-1],na.rm = TRUE))

cases.china <- cases %>% select(Date, cases = China)

# plot
p_Cases <- plotly::plot_ly(data = cases, 
                x = ~Date , y = ~China,
                mode = 'lines+markers')
  

p_Cases_logy <- p_Cases %>% plotly::layout(yaxis = list(type = "log", range=c(-.25,5)))
  
  # plot(x=cases$Date,y=cases$China,type="o",pch=20,cex=.7,log='y')

p_Cases_logy
```

## Using deconvolution to backcast the number symptomatic and exposed.

If we know the time between confirmation of cases and the time of first onset, we can reconstruct a time series of symptom onset (class $I$ in an SEIR model) from the case count using deconvolution.  If we know the incubation period, we can then reconstruct the time series of first exposure (class $E$ in and SEIR model) by a second deconvolution step.

The incubation period of COVID-19 has been estimated.

However, the time between symptom onset and case confirmation is variable, and changed throughout the early stages of the outbreak.

### Deconvolution of time series of cases to recreate time series of symptom onset

There are four different stages of the outbreak. Pre-January 9, January 9 to January 18, January 19 to January 23, and post-January 23. These timeframes are defined by Paige Miller in https://docs.google.com/document/d/1GpTvsoTZBWphn2tLbKHE5Z1ZE8RuD3caTHar-DqtqHc/edit?pli=1. The time between onset of symptoms and confirmation is distinct between these time frames.

**Table 1:** Period (in days) between symptom onset and case confirmation (mean, standard deviation and distribution) for each stage of the outbreak.

```{r stages, echo=FALSE}

# Deconvolution Stages
stages <- tibble(
  stage = c(1:4),
  start = as.Date(c('2019-12-01','2020-01-09','2020-01-19','2020-01-24')),
  end = c(as.Date(c('2020-01-08','2020-01-18','2020-01-23')),max(cases$Date)),
  mean = c(6.57,4.77,.812,.2),
  sd = c(4.78,3.11,1.12,.45),
  distribution = "lognorm")
stages
```

First, we set up a single database to hold the original data, parameters, and all derived time series: 

```{r database, echo=TRUE, message = FALSE, warning = FALSE}
# set up container

stage <- list()
for (i in 1:nrow(stages)) {
  stage[[i]] <- create_series(stages$start[i] ~ stages$end[i], period = '1 d',  class = "Date") %>% 
  mutate(stage = i, mean = stages$mean[i], sd = stages$sd[i], distribution = stages$distribution[i])
}
database <- tbl_time(bind_rows(stage), index = date) %>% 
  mutate(cases = cases$China) %>% rename(Date = date)
remove(stage)
timespan <- length(database$Date)
```

We can use a combination of the ridge regression transition matrix and random deconvolution to deconvolve the time-variant convolution. This method has not been tested yet, but it seems to work. 

```{r, echo=TRUE, message = FALSE, warning = FALSE}
estimates <- deconvolve_infection_curve_random_tv(as.data.frame(database))
incubation_matrix <- incubation_period_distribution_matrix_tv(
  outbreak_parms = as.data.frame(database), 
  rl = TRUE)
final_estimate <- deconvolve_infection_curve_rl(
  symptom_onset_curve = database$cases,
  matrix = incubation_matrix,
  estimate = estimates
  )
database$symptomatic <- round_infection_curve(database$cases, final_estimate)

# plot
p_Symptomatic <- plotly::plot_ly(data = database, x = ~Date , y = ~cases, name = 'confirmed', 
                     type = 'scatter', mode = 'lines') %>% 
  plotly::add_trace(y = ~symptomatic, name = 'symptomatic (estimated)', mode = 'lines')
  
p_Symptomatic_logy <- p_Symptomatic %>% plotly::layout(yaxis = list(type = "log", range=c(-.25,5)))
p_Symptomatic_logy
```

### Deconvolution of symptom onset curve to estimate exposure curve

Now we have a rough estimate of the number of people beginning to show symptoms each day. Next, we perform another deconvolution to estimate the number of people exposed each day. We estimate the exposure curve 20 times and calculate a 95% confidence interval. 

Deconvolution produces a time series of equal length to the original time series. However, since there is an average incubation period of 5.6 days before onset of symptoms, the last 8-10 days of the estimated exposure curve is not valid. We therefore have an estimated exposure curve with 95% confidence interval that brings us up to 10 days before the present.


```{r, echo=TRUE, message = FALSE, warning = FALSE}
#standard model inputs
shape <- 6.2
mean <- 5.6
scale <- mean/shape
sd <- sqrt(shape*scale^2)

parms <- c(mean,sd)
distribution <- "gamma"

na.tail <- round(mean+sd*2) # number of days at end of exposed time series to throw out

# perform deconvolution, return list of raw results (tail of each estimate is invalid)
exposed <- deconvolve_single_curve(database$symptomatic, parms)

# Replace tail of each estimate with NA's and store in database
database$exposed.mean <- tail_na(exposed$random,na.tail)
database$exposed.estimates <- as_tibble(tail_na(exposed$random_estimates,na.tail),
                                        .name_repair = 'universal'
                                        )

ci <- rowwise_confidence_intervals(database$exposed.estimates,interval=.95)
database$exposed.lower95 <- ci$lower
database$exposed.upper95 <- ci$upper

# plot
col.cases <- 'rgba(0, 0, 0, .75)'
col.symptomatic <- 'rgba(230, 7, 7, .75)'
col.exposed <- 'rgba(7, 164, 181, 0.75)'


p_Exposed <- plotly::plot_ly(data = database, x = ~Date , y = ~cases, type = 'scatter',
                             name = 'confirmed', mode = 'lines',
                             line = list(color = col.cases)
                             ) %>% 
  plotly::add_trace(y = ~symptomatic, 
                    name = 'symptomatic (estimated)', mode = 'lines',
                    line = list(color = col.symptomatic)) %>%
  plotly::add_trace(y = ~exposed.mean, 
                    name = 'exposed (mean)', mode = 'lines',
                    line = list(color = col.exposed)) %>% 
  plotly::add_ribbons(ymin = ~exposed.lower95, ymax = ~exposed.upper95,
                      name = 'exposed 95% confidence', mode='lines',
                      line = list(color = 'rgba(7, 164, 181, 0.05)'),
                      fillcolor = 'rgba(7, 164, 181, 0.2)'
                      )
  
p_Exposed_logy <- p_Exposed %>% plotly::layout(yaxis = list(type = "log", range=c(-.25,5)))
p_Exposed_logy
```

## Fit the exposed curve and forecast exposure curve

```{r, echo=TRUE, message = FALSE, warning = FALSE}

lag <- 1

exposed.model.tvar <- tvReg::tvAR(trim_na(database$exposed.mean), 
                          p = lag,  # number of lags
                          type = "none",  # model does not contain intercept
                          est="ll", # "local linear" non parametric estimation method
                          tkernel = "Gaussian")
exposed.forecast <- forecast::forecast(exposed.model.tvar$fitted,na.tail) #10 days forward

database$exposed.fit <- exposed.model.tvar$fitted %>% pad_na(lag, front = TRUE) %>% pad_na(na.tail)

database$exposed.fcast.mean <- exposed.forecast$mean %>% pmax(0) %>% 
  pad_na(timespan - na.tail, front = TRUE)
database$exposed.fcast.upper95 <- exposed.forecast$upper[,'95%'] %>% pmax(0) %>%
  pad_na(timespan - na.tail, front = TRUE)
database$exposed.fcast.lower95 <- exposed.forecast$lower[,'95%'] %>% pmax(0) %>%
  pad_na(timespan - na.tail, front = TRUE)

### Plot

col.cases <- 'rgba(0, 0, 0, .75)'
col.symptomatic <- 'rgba(230, 7, 7, .75)'
col.exposed <- 'rgba(7, 164, 181, 0.75)'
col.exposed.ci <- 'rgba(7, 164, 181, 0.25)'
col.fcast <- 'rgba(7, 7, 230, 0.75)'
col.fcast.ci <- 'rgba(7, 7, 230, 0.25)'

p_Exposed <- plotly::plot_ly(data = database, x = ~Date , y = ~cases, type = 'scatter',
                             name = 'confirmed', mode = 'lines',
                             line = list(color = col.cases)
                             ) %>% 
  plotly::add_trace(y = ~symptomatic, 
                    name = 'symptomatic (estimated)', mode = 'lines',
                    line = list(color = col.symptomatic)) %>%
  plotly::add_trace(y = ~exposed.mean, 
                    name = 'exposed (mean)', mode = 'lines',
                    line = list(color = col.exposed)) %>% 
  plotly::add_ribbons(ymin = ~exposed.lower95, ymax = ~exposed.upper95,
                      name = 'exposed 95% confidence', mode='lines',
                      line = list(color = col.exposed, width=.5),
                      fillcolor = col.exposed.ci) %>% 
  plotly::add_trace(y = ~exposed.fit, 
                    name = 'exposed (fitted)', mode = 'lines',
                    line = list(color = col.exposed, width = 1, dash = 'dot')) %>% 
  plotly::add_trace(y = ~exposed.fcast.mean, 
                    name = 'exposed (forecast mean)', mode = 'lines',
                    line = list(color = col.exposed, dash = 'dot')) %>% 
  plotly::add_ribbons(ymin = ~exposed.fcast.lower95, ymax = ~exposed.fcast.upper95,
                      name = 'exposed (forecast 95% confidence)', mode='lines',
                      line = list(color = col.exposed, width = .5),
                      fillcolor = col.exposed.ci
                      )
  
p_Exposed_logy <- p_Exposed %>% plotly::layout(yaxis = list(type = "log", range=c(-.25,5)))
p_Exposed_logy
```


## Estimate outbreak size

The mean esimated outbreak size at each time $t$ is the sum of the sympotmatic curve ($I$ class) and the mean estimated exposed curve ($E$ class) or mean forcested exposed curve.

For now, "upper 95" esimated outbreak size at each time $t$ is the sum of the sympotmatic curve ($I$ class) and the upper 95% exposed curve ($E$ class), or upper 95% forecasted exposed curve.

Ditto for lower 95.

Probably need to do a proper forecast of the sums rather than just sum the respective confidence interval bounds.

```{r, echo=TRUE, message = FALSE, warning = FALSE}

database <- database %>% 
  mutate(nowcast.mean = rowSums(
    dplyr::select(., symptomatic, exposed.mean, exposed.fcast.mean), na.rm = TRUE)
    ) %>% 
  mutate(nowcast.upper95 = rowSums(
    dplyr::select(., symptomatic, exposed.upper95, exposed.fcast.upper95), na.rm = TRUE)
    ) %>% 
  mutate(nowcast.lower95 = rowSums(
    dplyr::select(., symptomatic, exposed.lower95, exposed.fcast.lower95), na.rm = TRUE)
    )

# plot

col.cases <- 'rgba(0, 0, 0, .75)'
col.symptomatic <- 'rgba(230, 7, 7, .75)'
col.exposed <- 'rgba(7, 164, 181, 0.75)'
col.exposed.ci <- 'rgba(7, 164, 181, 0.25)'
col.fcast <- 'rgba(7, 7, 230, 0.75)'
col.fcast.ci <- 'rgba(7, 7, 230, 0.25)'

p_nowcast <- plotly::plot_ly(data = database, x = ~Date , y = ~cases, type = 'scatter',
                             name = 'confirmed', mode = 'lines',
                             line = list(color = col.cases)
                             ) %>% 
  plotly::add_trace(y = ~symptomatic, 
                    name = 'symptomatic (estimated)', mode = 'lines',
                    line = list(color = col.symptomatic)) %>%
  plotly::add_trace(y = ~exposed.mean, 
                    name = 'exposed (mean)', mode = 'lines',
                    line = list(color = col.exposed)) %>% 
  plotly::add_ribbons(ymin = ~exposed.lower95, ymax = ~exposed.upper95,
                      name = 'exposed 95% confidence', mode='lines',
                      line = list(color = col.exposed, width=.5),
                      fillcolor = col.exposed.ci) %>% 
  plotly::add_trace(y = ~exposed.fit, 
                    name = 'exposed (fitted)', mode = 'lines',
                    line = list(color = col.exposed, width = 1, dash = 'dot')) %>% 
  plotly::add_trace(y = ~exposed.fcast.mean, 
                    name = 'exposed (forecast mean)', mode = 'lines',
                    line = list(color = col.exposed, dash = 'dot')) %>% 
  plotly::add_ribbons(ymin = ~exposed.fcast.lower95, ymax = ~exposed.fcast.upper95,
                      name = 'exposed (forecast 95% confidence)', mode='lines',
                      line = list(color = col.exposed, width = .5),
                      fillcolor = col.exposed.ci
                      ) %>% 
  plotly::add_trace(y = ~nowcast.mean, 
                    name = 'nowcast (mean)', mode = 'lines',
                    line = list(color = col.fcast, dash = 'dot')) %>% 
  plotly::add_ribbons(ymin = ~nowcast.lower95, ymax = ~nowcast.upper95,
                      name = 'nowcast (95% confidence)', mode='lines',
                      line = list(color = col.fcast, width = .5),
                      fillcolor = col.fcast.ci
                      )
  
p_nowcast_logy <- p_nowcast %>% plotly::layout(yaxis = list(type = "log", range=c(-.25,5)))
p_nowcast_logy
```

